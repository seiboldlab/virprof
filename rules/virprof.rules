Env(name="virprof_r", base="bioconda",
    packages=[
        "r-magrittr",
        "r-dplyr",
        "r-readr",
        "r-purrr",
        "r-tidyr",
        "r-stringr",
        "r-fuzzyjoin",
        "r-tibble",
        "r-openxlsx",
        "r-optparse",
        "r-tidyverse",
        "r-patchwork",
        "r-ggrepel",
        "r-here",
        "bioconductor-iranges",
        "bedtools",
        "r-rentrez",
        "r-ggnewscale",
    ])

Env(name="virprof_py", base="bioconda",
    packages=[
        "graph-tool >=2.34",
        "biopython",
        "click",
        "tqdm",
        "networkx > 2",
        "requests",
    ])


with Stage("blastfilter_vp") as S:
    S.add_param("U", typ="int", name="min_unaligned_bp", default=0)
    S.doc("""This stage filters input FASTA based on BLAST hits to a
    contaminant database (e.g. host). Only sequences with at least
    Unnn basepairs not aligned to any sequence in the reference are
    passed through.""")

    rule vp_filter_blast:
        """Rule filtering individual FASTA file"""
        message:
            "Filtering contigs {output}"
        input:
            fasta  = "{:prev:}/{:target:}.fasta.gz",
            blast7 = "{:prev:}/{:target:}.blast7.gz"
        output:
            fasta  = "{:this:}/{target}.fasta.gz"
        log:
            "{:this:}/{target}.log"
        threads:
            1
        conda:
            "virprof_py"
        shell:"""
        exec >{log} 2>&1
        python -m virprof filter-blast \
         --min-unaligned-bp {params.min_unaligned_bp} \
         --out {output.fasta} \
         --in-fasta {input.fasta} \
         --in-blast7 {input.blast7}
        """

    rule vp_filter_blast_all:
        """Collection target in case this is the end of the pipeline"""
        message:
            "Completed {:this:}"
        input:
            "{:this:}/{:targets:}.fasta.gz"
        output:
            touch("{:this:}/all_targets.stamp")


with icfg.references.NcbiTaxonomy:
    rule vp_index_ncbi_taxonomy:
        """This rule loads the NCBI taxonomy, compiles it into a graph_tool
        tree and stores that tree in binary format. Loading the binary
        format tree is much faster than parsing the entire NCBI
        taxonomy from text files.

        The output file is added to the reference "NcbiTaxonomy".
        """
        message:
            "Creating taxonomy index for virprof bin&classify"
        input:
            ncbi_nodes = "{:prev:}/ALL.NCBI.nodes.dmp",
            ncbi_names = "{:prev:}/ALL.NCBI.names.dmp"
        output:
            "{:this:}/ALL.taxonomy.gt"
        log:
            "{:this:}/ALL.taxonomy.gt.log"
        threads:
            1
        params:
            taxonomy_prefix = lambda wc, input: input.ncbi_names[:-len("names.dmp")]
        conda:
            "virprof_py"
        shell:
            "exec >{log} 2>&1;"
            "python -m virprof index-tree"
            "  --library graph_tool"
            "  --ncbi-taxonomy {params.taxonomy_prefix}"
            "  --out {output}"


with Stage("blastbin_vp") as S:
    S.doc("""
    Creates bins from blast hits
    """)

    rule vp_blastbin:
        message:
            "Classifying - {output.result}"
        input:
            coverage = "{:prev:}/{:target:}.coverage",
            fasta    = "{:prev:}/{:target:}.fasta.gz",
            blast7   = "{:prev:}/{:target:}.blast7.gz",
            taxonomy = "{:prev:}/{:target:}.taxonomy.gt",
        output:
            result   = "{:this:}/{target}.virus.csv",
            hits     = "{:this:}/{target}.hits.csv",
            features = "{:this:}/{target}.features.csv",
        log:
                         "{:this:}/{target}.log"
        params:
            coverage = lambda wc, input: " --in-coverage ".join(ensure_list(input.coverage)),
            cache_path = "feature_table_cache",
            ncbi_api_key = ""
        threads:
            1
        conda:
            "virprof_py"
        shell:
            "exec >{log} 2>&1;"
            "python -m virprof blastbin"
            " --out {output.result}"
            " --out-hits {output.hits}"
            " --out-features {output.features}"
            " --ncbi-taxonomy {input.taxonomy}"
            " --in-blast7 {input.blast7}"
            " --in-coverage {params.coverage}"
            " --in-fasta {input.fasta}"
            " --cache-path {params.cache_path}"
            " --ncbi-api-key '{params.ncbi_api_key}'"

    rule vp_show_bins:
        message:
            "Visualizing binning"
        input:
            calls = "{:this:}/{target}.virus.csv",
            hits  = "{:this:}/{target}.hits.csv",
            features  = "{:this:}/{target}.features.csv",
            bam   = "{:prev:}/{:target:}.sorted.bam"
        output:
            plot =  "{:this:}/{target}.virus.pdf"
        log:
            "{:this:}/{target}.show_bins.log"
        threads:
            1
        conda:
            "virprof_r"
        params:
            page_width = 22,
            page_height = 18,
            plots_per_page = 5,
            min_slen = 200,
            min_reads = 3,
            bamlist = lambda wc, input: input.bam if isinstance(input.bam, str) else ",".join(input.bam),
        shell:
            "exec >{log} 2>&1;"
            "./R/show_bins.R"
            " --input {input.calls}"
            " --input-hits {input.hits}"
            " --input-features {input.features}"
            " --input-bam {params.bamlist}"
            " --output {output.plot}"
            " --page-width {params.page_width}"
            " --page-height {params.page_height}"
            " --plots-per-page {params.plots_per_page}"
            " --min-slen {params.min_slen}"
            " --min-reads {params.min_reads}"

    rule vp_classify_all:
        message:
            "Completed {:this:}"
        input:
            plots = "{:this:}/{:targets:}.virus.pdf",
        output:
            touch("{:this:}/all_targets.stamp")


with Stage("scaffold_vp") as S:
    S.doc("""
    Creates pseudo genomes from blast bins and contigs
    """)
    rule vp_scaffold_fasta:
        message:
            "Scaffolding genomes"
        input:
            bins  = "{:prev:}/{target}.virus.csv",
            hits  = "{:prev:}/{target}.hits.csv",
            fasta = "{:prev:}/{:target:}.fasta.gz"
        output:
            fasta =  "{:this:}/{target}.fasta.gz"
        log:
            "{:this:}/{target}.bin.log"
        threads: 1
        conda:
            "virprof_py"
        params:
            bin_by = "species",
            fasta_id_format = lambda wc: f"{wc.target}.{{sacc}} [bin={{bin_name}}] [bp={{bp}}]",
            max_fill_length = 50000,
        shell:
            "exec >{log} 2>&1;"
            "python -m virprof export-fasta"
            " --in-bins {input.bins}"
            " --in-hits {input.hits}"
            " --in-fasta {input.fasta}"
            " --out {output.fasta}"
            " --fasta-id-format '{params.fasta_id_format}'"
            " --scaffold"
            " --max-fill-length {params.max_fill_length}"
            " --bin-by {params.bin_by}"

    rule vp_scaffold_all:
        message:
            "Completed {:this:}"
        input:
            bins = "{:this:}/{:targets:}.fasta.gz"
        output:
            touch("{:this:}/all_targets.stamp")

with Stage("bin_vp") as S:
    S.doc("""Rearranges sequences from per-sample to per-bin fasta files""")
    S.add_param("", typ="choice", name="bin_by",
                value=['Species', 'Acc', 'Taxname'], default='Species')

    checkpoint vp_bin_fasta:
        message:
            """Sorting sequences into bins"""
        input:
            calls  = "{:prev:}/{:target:}.virus.csv",
            fasta = "{:prev:}/{:target:}.fasta.gz"
        output:
            bins =  "{:this:}/{target}.binlist.txt",
            fasta =  "{:this:}/{target}.{:bin:}.fasta.gz",
            call_flist = temp("{:this:}/{target}.call_flist"),
            fasta_flist = temp("{:this:}/{target}.fasta_flist"),
        log:
            "{:this:}/{target}.bin.log"
        threads: 1
        conda:
            "virprof_py"
        params:
            calls = lambda wc, input: "\n".join(input.calls),
            fastas = lambda wc, input: "\n".join(input.fasta),
            out_bins = "{:this:}/%s.fasta.gz",
            filter_lineage = "^Virus",
        shell:
            "exec >{log} 2>&1;"
            "echo '{params.calls}' > {output.call_flist};\n"
            "echo '{params.fastas}' > {output.fasta_flist};\n"
            "python -m virprof find-bins"
            " --in-call-files {output.call_flist}"
            " --in-fasta-files {output.fasta_flist}"
            " --filter-lineage {params.filter_lineage}"
            " --bin-by {params.bin_by}"
            " --out {params.out_bins}"
            " --out-bins {output.bins}"

    rule vp_bin_fasta_all:
        message:
            "Completed {:this:}"
        input:
            bins = "{:this:}/{:targets:}.binlist.txt"
        output:
            touch("{:this:}/all_targets.stamp")


with Stage("summarize_vp") as S:
    rule vp_aggregate_classifiations:
        message:
            "Creating virus summary for {wildcards.target} in {:this:}"
        input:
            virushostdb="{:prev:}/virushostdb.tsv",
            calls="{:prev:}/{:target:}.virus.csv",
            coverages="{:prev:}/{:target:}.coverage",
            basecov="{:prev:}/{:target:}.basecov.bg",
        output:
            excel="{:this:}/{target}.summary.xlsx"
        log:
            "{:this:}/{target}.summary.log"
        params:
            calls       = lambda wc, input: "\n".join(input.calls),
            coverages   = lambda wc, input: "\n".join(input.coverages),
            basecov     = lambda wc, input: "\n".join(input.basecov),
            csv_out     = "{:this:}/{target}.summary_%s.csv",
            filter_host = "Homo sapiens",
            min_slen    = 200,
            min_reads   = 3,
        shadow:
            "shallow"
        threads:
            1
        conda:
            "virprof_r"
        shell:
            "exec >{log} 2>&1;\n"
            "\n"
            "echo '{params.calls}' > call.files;\n"
            "echo '{params.coverages}' > coverage.files;\n"
            "echo '{params.basecov}' > basecov.files;\n"
            "\n"
            "./R/aggregate_classifications.R"
            "  --virushostdb '{input.virushostdb}'"
            "  --filter-host '{params.filter_host}'"
            "  --min-slen '{params.min_slen}'"
            "  --min-reads '{params.min_reads}'"
            "  --excel-out '{output.excel}'"
            "  --out '{params.csv_out}'"
            "  --in-list call.files"
            "  --in-coverage-list coverage.files"
            "  --in-basecov-list basecov.files"

    rule vp_aggregate_genomes:
        message:
            "Copying genome files to {:this:}"
        input:
            fasta = "{:prev:}/{:target:}.fasta.gz"
        output:
            fasta_list = "{:this:}/{target}.genomes.txt"
        log:
            "{:this:}/{target}.genomes.log"
        params:
            this = "{:this:}"
        shell:
            "exec >{log} 2>&1;"
            "echo > {output.fasta_list};"
            "for path in {input.fasta}; do"
            "  name=$(basename $path);"
            "  echo $name >> {output.fasta_list};"
            "  cp -v $path {params.this}/{wildcards.target}.$name;"
            "done;"

    rule vp_summarize_all:
        message:
            "Completed {:this:}"
        input:
            summary = "{:this:}/{:targets:}.summary.xlsx",
            fasta = "{:this:}/{:targets:}.genomes.txt"
        output:
            touch("{:this:}/all_targets.stamp")
