Env(name="virprof_r", base="bioconda",
    packages=[
        "r-magrittr",
        "r-dplyr",
        "r-readr",
        "r-purrr",
        "r-tidyr",
        "r-stringr",
        "r-fuzzyjoin",
        "r-tibble",
        "r-openxlsx",
        "r-optparse",
        "r-tidyverse",
        "r-patchwork",
        "r-ggrepel",
        "r-here",
        "bioconductor-iranges",
        "bedtools",
        "r-rentrez",
        "r-ggnewscale",
    ])

Env(name="virprof_py", base="bioconda",
    packages=[
        "graph-tool >=2.34",
        "biopython",
        "click",
        "tqdm",
        "networkx > 2",
        "requests",
    ])


with Stage("blastfilter_vp") as S:
    S.add_param("U", typ="int", name="min_unaligned_bp", default=0)
    S.doc("""This stage filters input FASTA based on BLAST hits to a
    contaminant database (e.g. host). Only sequences with at least
    Unnn basepairs not aligned to any sequence in the reference are
    passed through.""")

    rule vp_filter_blast:
        """Rule filtering individual FASTA file"""
        message:
            "Filtering contigs {output}"
        input:
            fasta  = "{:prev:}/{:target:}.fasta.gz",
            blast7 = "{:prev:}/{:target:}.blast7.gz"
        output:
            fasta  = "{:this:}/{target}.fasta.gz"
        log:
            "{:this:}/{target}.log"
        threads:
            1
        conda:
            "virprof_py"
        shell:"""
        exec >{log} 2>&1
        python -m virprof filter-blast \
         --min-unaligned-bp {params.min_unaligned_bp} \
         --out {output.fasta} \
         --in-fasta {input.fasta} \
         --in-blast7 {input.blast7}
        """

    rule vp_filter_blast_all:
        """Collection target in case this is the end of the pipeline"""
        message:
            "Completed {:this:}"
        input:
            "{:this:}/{:targets:}.fasta.gz"
        output:
            touch("{:this:}/all_targets.stamp")


with icfg.references.NcbiTaxonomy:
    rule vp_index_ncbi_taxonomy:
        """This rule loads the NCBI taxonomy, compiles it into a graph_tool
        tree and stores that tree in binary format. Loading the binary
        format tree is much faster than parsing the entire NCBI
        taxonomy from text files.

        The output file is added to the reference "NcbiTaxonomy".
        """
        message:
            "Creating taxonomy index for virprof bin&classify"
        input:
            ncbi_nodes = "{:prev:}/ALL.NCBI.nodes.dmp",
            ncbi_names = "{:prev:}/ALL.NCBI.names.dmp"
        output:
            "{:this:}/ALL.taxonomy.gt"
        log:
            "{:this:}/ALL.taxonomy.gt.log"
        threads:
            1
        params:
            taxonomy_prefix = lambda wc, input: input.ncbi_names[:-len("names.dmp")]
        conda:
            "virprof_py"
        shell:
            "exec >{log} 2>&1;"
            "python -m virprof index-tree"
            "  --library graph_tool"
            "  --ncbi-taxonomy {params.taxonomy_prefix}"
            "  --out {output}"


with Stage("blastbin_vp") as S:
    S.doc("""
    Creates bins from blast hits
    """)

    rule vp_blastbin:
        message:
            "Classifying - {output.result}"
        input:
            coverage = "{:prev:}/{:target:}.coverage",
            fasta    = "{:prev:}/{:target:}.fasta.gz",
            blast7   = "{:prev:}/{:target:}.blast7.gz",
            taxonomy = "{:prev:}/{:target:}.taxonomy.gt",
        output:
            result   = "{:this:}/{target}.virus.csv",
            hits     = "{:this:}/{target}.hits.csv",
            features = "{:this:}/{target}.features.csv",
        log:
                         "{:this:}/{target}.log"
        params:
            coverage = lambda wc, input: " --in-coverage ".join(ensure_list(input.coverage)),
            cache_path = "feature_table_cache",
            ncbi_api_key = ""
        threads:
            1
        conda:
            "virprof_py"
        shell:
            "exec >{log} 2>&1;"
            "python -m virprof blastbin"
            " --out {output.result}"
            " --out-hits {output.hits}"
            " --out-features {output.features}"
            " --ncbi-taxonomy {input.taxonomy}"
            " --in-blast7 {input.blast7}"
            " --in-coverage {params.coverage}"
            " --in-fasta {input.fasta}"
            " --cache-path {params.cache_path}"
            " --ncbi-api-key '{params.ncbi_api_key}'"

    rule vp_show_bins:
        message:
            "Visualizing binning"
        input:
            calls = "{:this:}/{target}.virus.csv",
            hits  = "{:this:}/{target}.hits.csv",
            features  = "{:this:}/{target}.features.csv",
            bam   = "{:prev:}/{:target:}.sorted.bam"
        output:
            plot =  "{:this:}/{target}.virus.pdf"
        log:
            "{:this:}/{target}.show_bins.log"
        threads:
            1
        conda:
            "virprof_r"
        params:
            page_width = 22,
            page_height = 18,
            plots_per_page = 5,
            min_slen = 200,
            min_reads = 3,
            bamlist = lambda wc, input: input.bam if isinstance(input.bam, str) else ",".join(input.bam),
        shell:
            "exec >{log} 2>&1;"
            "./R/show_bins.R"
            " --input {input.calls}"
            " --input-hits {input.hits}"
            " --input-features {input.features}"
            " --input-bam {params.bamlist}"
            " --output {output.plot}"
            " --page-width {params.page_width}"
            " --page-height {params.page_height}"
            " --plots-per-page {params.plots_per_page}"
            " --min-slen {params.min_slen}"
            " --min-reads {params.min_reads}"

    rule vp_classify_all:
        message:
            "Completed {:this:}"
        input:
            plots = "{:this:}/{:targets:}.virus.pdf",
        output:
            touch("{:this:}/all_targets.stamp")


with Stage("scaffold_vp") as S:
    S.doc("""
    Creates pseudo genomes from blast bins and contigs
    """)
    rule vp_scaffold_fasta:
        message:
            "Scaffolding genomes"
        input:
            bins  = "{:prev:}/{target}.virus.csv",
            hits  = "{:prev:}/{target}.hits.csv",
            fasta = "{:prev:}/{:target:}.fasta.gz"
        output:
            fasta =  "{:this:}/{target}.fasta.gz"
        log:
            "{:this:}/{target}.bin.log"
        threads: 1
        conda:
            "virprof_py"
        params:
            filter_lineage = "^Virus",
            bin_by = "species",
            fasta_id_format = lambda wc: f"{wc.target}.{{sacc}} [bin={{bin_name}}] [contigs={{acc}}] [bp={{bp}}]",
            max_fill_length = 50000,
        shell:
            "exec >{log} 2>&1;"
            "python -m virprof export-fasta"
            " --in-bins {input.bins}"
            " --in-hits {input.hits}"
            " --in-fasta {input.fasta}"
            " --out {output.fasta}"
            " --fasta-id-format '{params.fasta_id_format}'"
            " --scaffold"
            " --max-fill-length {params.max_fill_length}"
            " --bin-by {params.bin_by}"

    rule vp_scaffold_all:
        message:
            "Completed {:this:}"
        input:
            bins = "{:this:}/{:targets:}.fasta.gz"
        output:
            touch("{:this:}/all_targets.stamp")


with Stage("export_vp") as S:
    S.doc("""
    Creates genomes from blast bins and contigs
    """)
    checkpoint vp_export_fasta:
        message:
            "Exporting recovered genomes into bins"
        input:
            bins  = "{:prev:}/{target}.virus.csv",
            hits  = "{:prev:}/{target}.hits.csv",
            fasta = "{:prev:}/{:target:}.fasta.gz"
        output:
            bins =  "{:this:}/{target}.filelist.txt",
            fasta =  "{:this:}/{target}.{:bin:}.fasta.gz"
        log:
            "{:this:}/{target}.bin.log"
        threads: 1
        conda:
            "virprof_py"
        params:
            out_bins = "{:this:}/{target}__%s.fasta.gz",
            out_bins_unmerged = "{:this:}/{target}__%s.unmerged.fasta.gz",
            bin_by = "species",
            filter_lineage = "^Virus",
            fasta_id_format = lambda wc: f"{wc.target}.{{bin_name}} [accession={{sacc}}] [contigs={{acc}}] [bp={{bp}}]"
        shell:
            "exec >{log} 2>&1;"
            "python -m virprof export-fasta"
            " --in-bins {input.bins}"
            " --in-hits {input.hits}"
            " --in-fasta {input.fasta}"
            " --out {params.out_bins}"
            " --out-bins {output.bins}"
            " --bin-by {params.bin_by}"
            " --filter-lineage {params.filter_lineage}"
            " --fasta-id-format '{params.fasta_id_format}'"
            " --file-per-bin"
            " --merge-overlapping"
            ";"
            "python -m virprof export-fasta"
            " --in-bins {input.bins}"
            " --in-hits {input.hits}"
            " --in-fasta {input.fasta}"
            " --out {params.out_bins_unmerged}"
            " --bin-by {params.bin_by}"
            " --filter-lineage {params.filter_lineage}"
            " --fasta-id-format '{params.fasta_id_format}'"
            " --file-per-bin"
            " --no-merge-overlapping"

    rule vp_export_all:
        message:
            "Completed {:this:}"
        input:
            bins = "{:this:}/{:targets:}.filelist.txt"
        output:
            touch("{:this:}/all_targets.stamp")


with Stage("summarize_vp") as S:
    rule vp_aggregate_classifiations:
        message:
            "Creating virus summary for {wildcards.target} in {:this:}"
        input:
            virushostdb="{:prev:}/virushostdb.tsv",
            calls="{:prev:}/{:target:}.virus.csv",
            coverages="{:prev:}/{:target:}.coverage",
            basecov="{:prev:}/{:target:}.basecov.bg",
        output:
            excel="{:this:}/{target}.summary.xlsx"
        log:
            "{:this:}/{target}.summary.log"
        params:
            calls       = lambda wc, input: "\n".join(input.calls),
            coverages   = lambda wc, input: "\n".join(input.coverages),
            basecov     = lambda wc, input: "\n".join(input.basecov),
            csv_out     = "{:this:}/{target}.summary_%s.csv",
            filter_host = "Homo sapiens",
            min_slen    = 200,
            min_reads   = 3,
        shadow:
            "shallow"
        threads:
            1
        conda:
            "virprof_r"
        shell:
            "exec >{log} 2>&1;\n"
            "\n"
            "echo '{params.calls}' > call.files;\n"
            "echo '{params.coverages}' > coverage.files;\n"
            "echo '{params.basecov}' > basecov.files;\n"
            "\n"
            "./R/aggregate_classifications.R"
            "  --virushostdb '{input.virushostdb}'"
            "  --filter-host '{params.filter_host}'"
            "  --min-slen '{params.min_slen}'"
            "  --min-reads '{params.min_reads}'"
            "  --excel-out '{output.excel}'"
            "  --out '{params.csv_out}'"
            "  --in-list call.files"
            "  --in-coverage-list coverage.files"
            "  --in-basecov-list basecov.files"

    rule vp_aggregate_genomes:
        message:
            "Copying genome files to {:this:}"
        input:
            fasta = "{:prev:}/{:target:}.fasta.gz"
        output:
            fasta_list = "{:this:}/{target}.genomes.txt"
        log:
            "{:this:}/{target}.genomes.log"
        params:
            this = "{:this:}"
        shell:
            "exec >{log} 2>&1;"
            "echo > {output.fasta_list};"
            "for path in {input.fasta}; do"
            "  name=$(basename $path);"
            "  echo $name >> {output.fasta_list};"
            "  cp -v $path {params.this}/{wildcards.target}.$name;"
            "done;"

    rule vp_summarize_all:
        message:
            "Completed {:this:}"
        input:
            summary = "{:this:}/{:targets:}.summary.xlsx",
            fasta = "{:this:}/{:targets:}.genomes.txt"
        output:
            touch("{:this:}/all_targets.stamp")
