Env(name="virprof_r", base="bioconda",
    packages=[
        "r-magrittr",
        "r-dplyr",
        "r-readr",
        "r-purrr",
        "r-tidyr",
        "r-stringr",
        "r-fuzzyjoin",
        "r-tibble",
        "r-openxlsx",
        "r-optparse",
        "r-tidyverse",
        "r-patchwork",
        "r-ggrepel",
        "r-here",
        "bioconductor-iranges",
        "bedtools",
        "r-rentrez",
        "r-ggnewscale",
    ])

Env(name="virprof_py", base="bioconda",
    packages=[
        "graph-tool >=2.34",
        "biopython",
        "click",
        "tqdm",
        "networkx > 2",
        "requests",
    ])

BIN = srcdir("../bin/")


with Stage("get_unmapped_vp") as S:
    S.require(
        data = [["bam"], ["salmon/aux_info/unmapped_names.txt"]],
        fq = [["R1.fq.gz", "R2.fq.gz"]],
    )
    rule vp_unmapped_from_bam:
        message:
            "{:name:}: {output.pairs[0]} from BAM"
        input:
            bam =  "{:prev:}/{target}.bam"
        output:
            pairs = "{:this:}/{target}.{:pairnames:}.fq.gz"
        log:
            "{:this:}/{target}.log"
        benchmark:
            "benchmarks/{:name:}/{:this:}/{target}.txt"
        threads:
            4
        resources:
            mem = "8g"
        params:
            f = 12,
            F = 0x900,
            G = 0,
        conda:
            "samtools"
        shell:
            "samtools fastq"
            " -1 {output.pairs[0]}"
            " -2 {output.pairs[1]}"
            " --threads {threads}"
            " -f {params.f}"
            " -F {params.F}"
            " -G {params.G}"
            " {input}"
            " 2>&1 >{log}"

    rule vp_unmapped_from_salmon:
        message:
            "{:name:}: {output.fq[0]} from Salmon unmapped names"
        input:
            fq = "{:prev:}/{target}.{:pairnames:}.fq.gz",
            unmapped = "{:prev:}/{target}.salmon/aux_info/unmapped_names.txt",
        output:
            fq = "{:this:}/{target}.{:pairnames:}.fq.gz"
        log:
            "{:this:}/{target}.log"
        benchmark:
            "benchmarks/{:name:}/{:this:}/{target}.txt"
        threads:
            8
        resources:
            mem="32g"
        params:
            pattern = "u"
        conda:
            "bbmap"
        shell:
            "exec >{log} 2>&1;"
            "grep '{params.pattern}$' {input.unmapped} |"
            "  cut -d' ' -f1 |"
            "  filterbyname.sh"
            "    in={input.fq[0]}"
            "    in2={input.fq[1]}"
            "    out={output.fq[0]}"
            "    out2={output.fq[1]}"
            "    names=/dev/stdin"
            "    include=t"
            "    -Xmx{resources.mem_mb}m"
            "    -eoom"


with Stage("index_vp") as S:
    rule vp_index_ncbi_taxonomy:
        """This rule loads the NCBI taxonomy, compiles it into a graph_tool
        tree and stores that tree in binary format. Loading the binary
        format tree is much faster than parsing the entire NCBI
        taxonomy from text files.

        The output file is added to the reference "NcbiTaxonomy".
        """
        message:
            "{:name:}: Creating graph tool binary format tree from NCBI taxonomy"
        input:
            ncbi_nodes = "{:prev:}/ALL.NCBI.nodes.dmp",
            ncbi_names = "{:prev:}/ALL.NCBI.names.dmp",
            ncbi_merged = "{:prev:}/ALL.NCBI.merged.dmp",
        output:
            "{:this:}/ALL.taxonomy.gt"
        log:
            "{:this:}/ALL.taxonomy.gt.log"
        benchmark:
            "benchmarks/{:name:}/{:this:}/ALL.txt"
        threads:
            1
        params:
            taxonomy_prefix = lambda wc, input: input.ncbi_names[:-len("names.dmp")]
        conda:
            "virprof_py"
        shell:
            "exec >{log} 2>&1;"
            "{BIN}/virprof index-tree"
            "  --library graph_tool"
            "  --ncbi-taxonomy {params.taxonomy_prefix}"
            "  --out {output}"


with Stage("blastfilter_vp") as S:
    S.add_param("U", typ="int", name="min_unaligned_bp", default=0)
    S.doc("""This stage filters input FASTA based on BLAST hits to a
    contaminant database (e.g. host). Only sequences with at least
    Unnn basepairs not aligned to any sequence in the reference are
    passed through.""")

    rule vp_filter_blast:
        """Rule filtering individual FASTA file"""
        message:
            "{:name:}: Filtering contigs {output}"
        input:
            fasta  = "{:prev:}/{:target:}.fasta.gz",
            blast7 = "{:prev:}/{:target:}.blast7.gz"
        output:
            fasta  = "{:this:}/{target}.fasta.gz"
        log:
            "{:this:}/{target}.log"
        benchmark:
            "benchmarks/{:name:}/{:this:}/{target}.txt"
        threads:
            1
        conda:
            "virprof_py"
        shell:"""
        exec >{log} 2>&1
        {BIN}/virprof filter-blast \
         --min-unaligned-bp {params.min_unaligned_bp} \
         --out {output.fasta} \
         --in-fasta {input.fasta} \
         --in-blast7 {input.blast7}
        """

    rule vp_filter_blast_all:
        """Collection target in case this is the end of the pipeline"""
        message:
            "Completed {:this:}"
        input:
            "{:this:}/{:targets:}.fasta.gz"
        output:
            touch("{:this:}/all_targets.stamp")


with Stage("blastbin_vp") as S:
    S.doc("""
    Creates bins from blast hits
    """)

    rule vp_blastbin:
        message:
            "{:name:}: Classifying {output.result}"
        input:
            coverage = "{:prev:}/{:target:}.coverage",
            fasta    = "{:prev:}/{:target:}.fasta.gz",
            blast7   = "{:prev:}/{:target:}.blast7.gz",
            taxonomy = "{:prev:}/{:target:}.taxonomy.gt",
        output:
            result   = "{:this:}/{target}.virus.csv",
            hits     = "{:this:}/{target}.hits.csv",
            features = "{:this:}/{target}.features.csv",
        log:
                         "{:this:}/{target}.log"
        benchmark:
            "benchmarks/{:name:}/{:this:}/{target}.blastbin.txt"
        params:
            coverage = lambda wc, input: " --in-coverage ".join(ensure_list(input.coverage)),
            cache_path = "feature_table_cache",
            ncbi_api_key = ""
        threads:
            1
        conda:
            "virprof_py"
        shell:
            "exec >{log} 2>&1;"
            "{BIN}/virprof blastbin"
            " --out {output.result}"
            " --out-hits {output.hits}"
            " --out-features {output.features}"
            " --ncbi-taxonomy {input.taxonomy}"
            " --in-blast7 {input.blast7}"
            " --in-coverage {params.coverage}"
            " --in-fasta {input.fasta}"
            " --cache-path {params.cache_path}"
            " --ncbi-api-key '{params.ncbi_api_key}'"

    rule vp_bins_to_rds:
        message:
            "{:name:}: Exporting bins to RDS"
        input:
            calls = "{:this:}/{target}.virus.csv",
            hits  = "{:this:}/{target}.hits.csv",
            features  = "{:this:}/{target}.features.csv",
            bam   = "{:prev:}/{:target:}.sorted.bam"
        output:
            rds = "{:this:}/{target}.vp.rds",
        log:
            "{:this:}/{target}.vp.rds.log"
        benchmark:
            "benchmarks/{:name:}/{:this:}/{target}.vp.rds.txt"
        threads:
            1
        conda:
            "virprof_r"
        script:
            "vpimport.R"


with Stage("scaffold_vp") as S:
    S.doc("""
    Creates pseudo genomes from blast bins and contigs
    """)
    rule vp_scaffold_fasta:
        message:
            "{:name:}: Scaffolding {output.fasta}"
        input:
            bins  = "{:prev:}/{target}.virus.csv",
            hits  = "{:prev:}/{target}.hits.csv",
            fasta = "{:prev:}/{:target:}.fasta.gz"
        output:
            fasta =  "{:this:}/{target}.fasta.gz",
            scaffolds = "{:this:}/{target}.scaffolds.csv"
        log:
            "{:this:}/{target}.bin.log"
        benchmark:
            "benchmarks/{:name:}/{:this:}/{target}.txt"
        threads: 1
        conda:
            "virprof_py"
        params:
            bin_by = "species",
            fasta_id_format = lambda wc: f"{wc.target}.{{sacc}} [bin={{bin_name}}] [bp={{bp}}]",
            max_fill_length = 50000,
        shell:
            "exec >{log} 2>&1;"
            "{BIN}/virprof export-fasta"
            " --in-bins {input.bins}"
            " --in-hits {input.hits}"
            " --in-fasta {input.fasta}"
            " --out {output.fasta}"
            " --out-scaffolds {output.scaffolds}"
            " --fasta-id-format '{params.fasta_id_format}'"
            " --scaffold"
            " --max-fill-length {params.max_fill_length}"
            " --bin-by {params.bin_by}"

    rule vp_scaffold_all:
        message:
            "Completed {:this:}"
        input:
            bins = "{:this:}/{:targets:}.fasta.gz"
        output:
            touch("{:this:}/all_targets.stamp")

with Stage("collect_vp") as S:
    S.doc("""
    Collects pipeline data into RDS format files
    """)
    rule vp_show_bins:
        message:
            "{:name:}: Visualizing bins {output}"
        input:
            calls = "{:prev:}/{:target:}.virus.csv",
            hits  = "{:prev:}/{:target:}.hits.csv",
            features  = "{:prev:}/{:target:}.features.csv",
            bam   = "{:prev:}/{:target:}.sorted.bam"
        output:
            plot =  "{:this:}/{target}.virus.pdf",
            data = "{:this:}/{target}.vp.rds",
        log:
            "{:this:}/{target}.show_bins.log"
        benchmark:
            "benchmarks/{:name:}/{:this:}/{target}.show_bins.txt"
        threads:
            1
        conda:
            "virprof_r"
        params:
            page_width = 15,
            page_height = 4,
            plots_per_page = 1,
            min_slen = 200,
            min_reads = 2,
            bamlist = lambda wc, input: input.bam if isinstance(input.bam, str) else ",".join(input.bam),
        shell:
            "exec >{log} 2>&1;"
            "{BIN}/show_bins.R"
            " --input {input.calls}"
            " --input-hits {input.hits}"
            " --input-features {input.features}"
            " --input-bam {params.bamlist}"
            " --output {output.plot}"
            " --output-rds {output.data}"
            " --page-width {params.page_width}"
            " --page-height {params.page_height}"
            " --plots-per-page {params.plots_per_page}"
            " --min-slen {params.min_slen}"
            " --min-reads {params.min_reads}"


with Stage("bin_vp") as S:
    S.doc("""Rearranges sequences from per-sample to per-bin fasta files""")
    S.add_param("", typ="choice", name="bin_by",
                value=['Species', 'Acc', 'Taxname'], default='Species')

    rule vp_bin_fasta_file_lists:
        message:
            "{:name:}: Collecting input files"
        input:
            calls  = "{:prev:}/{:target:}.virus.csv",
            fasta = "{:prev:}/{:target:}.fasta.gz",
        output:
            call_flist = temp("{:this:}/{target}.call_flist"),
            fasta_flist = temp("{:this:}/{target}.fasta_flist"),
        run:
            with open(output.call_flist, "w") as out:
                for call in input.calls:
                    print(call, file=out)
            with open(output.fasta_flist, "w") as out:
                for fasta in input.fasta:
                    print(fasta, file=out)
    localrules: vp_bin_fasta_file_lists

    checkpoint vp_bin_fasta:
        message:
            "{:name:}: Sorting sequences into bins {output.bins}"
        input:
            call_flist = "{:this:}/{target}.call_flist",
            fasta_flist = "{:this:}/{target}.fasta_flist",
        output:
            bins =  "{:this:}/{target}.binlist.txt",
            fasta =  "{:this:}/{target}.{:bin:}.fasta.gz",
        log:
            "{:this:}/{target}.bin.log"
        benchmark:
            "benchmarks/{:name:}/{:this:}/{target}.txt"
        threads: 1
        conda:
            "virprof_py"
        params:
            out_bins = "{:this:}/%s.fasta.gz",
            filter_lineage = "^Virus",
        shell:
            "exec >{log} 2>&1;"
            "{BIN}/virprof find-bins"
            " --in-call-files {input.call_flist}"
            " --in-fasta-files {input.fasta_flist}"
            " --filter-lineage {params.filter_lineage}"
            " --bin-by {params.bin_by}"
            " --out {params.out_bins}"
            " --out-bins {output.bins}"

    rule vp_bin_fasta_all:
        message:
            "Completed {:this:}"
        input:
            bins = "{:this:}/{:targets:}.binlist.txt"
        output:
            touch("{:this:}/all_targets.stamp")


with Stage("summarize_vp") as S:
    rule vp_aggregate_classifications:
        message:
            "{:name:}: Creating virus summary {output.excel}"
        input:
            virushostdb="{:prev:}/virushostdb.tsv",
            calls="{:prev:}/{:target:}.virus.csv",
            coverages="{:prev:}/{:target:}.coverage",
            basecov="{:prev:}/{:target:}.basecov.bg",
            scaffolds="{:prev:}/{:target:}.scaffolds.csv",
            data="{:prev:}/{:target:}.vp.rds",
        output:
            call_files=temp("{:this:}/{target}.call_flist"),
            coverage_files=temp("{:this:}/{target}.coverage_flist"),
            basecov_files=temp("{:this:}/{target}.basecov_flist"),
            scaffold_files=temp("{:this:}/{target}.scaffold_flist"),
            excel="{:this:}/{target}.summary.xlsx",
        benchmark:
            "benchmarks/{:name:}/{:this:}/{target}.txt"
        log:
            "{:this:}/{target}.summary.log"
        params:
            calls       = lambda wc, input: "\n".join(input.calls),
            coverages   = lambda wc, input: "\n".join(input.coverages),
            basecov     = lambda wc, input: "\n".join(input.basecov),
            scaffolds   = lambda wc, input: "\n".join(input.scaffolds),
            csv_out     = "{:this:}/{target}.summary_%s.csv",
            filter_host = "Homo sapiens",
            min_bp      = 200,
            min_reads   = 3,
            reporttpl   = "{:ensuredir.reports:}/{:project:}.pathogens.summary.%Y-%m-%d_%H-%M.xlsx",
            project = "{:project:}",
            slack_hook  = "",  # should be trailing part of form xxx/xxx/xxx
        threads:
            1
        conda:
            "virprof_r"
        shell:
            "exec >{log} 2>&1;\n"
            "\n"
            "echo '{params.calls}' > {output.call_files};\n"
            "echo '{params.coverages}' > {output.coverage_files};\n"
            "echo '{params.basecov}' > {output.basecov_files};\n"
            "echo '{params.scaffolds}' > {output.scaffold_files};\n"
            "\n"
            "{BIN}/aggregate_classifications.R"
            "  --virushostdb '{input.virushostdb}'"
            "  --filter-host '{params.filter_host}'"
            "  --min-bp '{params.min_bp}'"
            "  --min-reads '{params.min_reads}'"
            "  --excel-out '{output.excel}'"
            "  --out '{params.csv_out}'"
            "  --in-list {output.call_files}"
            "  --in-coverage-list {output.coverage_files}"
            "  --in-scaffold-list {output.scaffold_files}"
            "  --in-basecov-list {output.basecov_files};\n"
            "\n"
            "MSG=\"New pathogen results for \`{params.project}\`:\n\n\";"
            "REPORT=$(date +{params.reporttpl});"
            "MSG=\"$MSG\n- \`$REPORT\`\";"
            "cp -v {output.excel} $REPORT;"
            "\n"
            "if [ -n \"{params.slack_hook}\" ]; then"
            "  curl"
            "    --silent"
            "    --request POST"
            "    --header 'Content-type: application/json'"
            "    --data '{{\"text\":\"'\"$MSG\"'\"}}'"
            "    https://hooks.slack.com/services/{params.slack_hook};"
            "  fi;"


    rule vp_aggregate_genomes:
        message:
            "{:name:}: Copying genome files to {:this:}"
        input:
            fasta = "{:prev:}/{:target:}.fasta.gz"
        output:
            fasta_list = "{:this:}/{target}.genomes.txt"
        log:
            "{:this:}/{target}.genomes.log"
        params:
            this = "{:this:}"
        shell:
            "exec >{log} 2>&1;"
            "echo > {output.fasta_list};"
            "for path in {input.fasta}; do"
            "  name=$(basename $path);"
            "  echo $name >> {output.fasta_list};"
            "  cp -v $path {params.this}/{wildcards.target}.$name;"
            "done;"

    rule vp_summarize_all:
        message:
            "Completed {:this:}"
        input:
            summary = "{:this:}/{:targets:}.summary.xlsx",
            fasta = "{:this:}/{:targets:}.genomes.txt"
        output:
            touch("{:this:}/all_targets.stamp")
